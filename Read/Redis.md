如何保证数据库与缓存的一致性？

由于缓存和数据库是分开的，无法做到原子性的同时进行数据修改，可能出现缓存更新失败，或者数据库更新失败的情况，这时候会出现数据不一致，影响前端业务

- 先更新数据库，再更新缓存。缓存可能更新失败，读到老数据
- 先删缓存，再更新数据库。并发时，读操作可能还是会将旧数据读回缓存
- 先更新数据库，再删缓存。也存在缓存删除失败的可能

最经典的缓存+数据库读写的模式，**Cache Aside Pattern**。

读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。

更新的时候，先更新数据库，然后再删除缓存。

**为什么是删除而不是更新?**

删除更加轻量，延迟加载的一种实现，更新可能涉及多个表、比较耗时

**延时双删:**先删除缓存，再更新数据库，休眠1s、再次删除缓存。写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据，并发还是可能读到旧值覆盖缓存

终极方案

将访问操作串行化

- 先删缓存，将更新数据库的操作放进有序队列中
- 从缓存查不到的查询操作，都进入有序队列

会面临的问题

- 读请求积压，大量超时，导致数据库的压力: 限流、熔断
- 如何避免大量请求积压: 将队列水平拆分，提高并行度
- 保证相同请求路由正确。

redis的持久化机制

RDB：将某一时刻的内存快照，以二进制的方式写入磁盘

手动触发：

- save命令，使redis处于阻塞状态，直到RDB持久化完成，才会响应其它客户端发来的命令
- bgsave命令，fork出一个子进程执行持久化，主进程只在fork过程中有短暂的阻塞，子进程创建之后，主进程就可以响应客户端的请求。**cow 写时拷贝策略：**父进程执行写命令，不操作共享内存，将数据拷贝出来一个副本，对副本进行修改。保证某一时刻快照的准确性，起到数据隔离的作用。

自动触发：

- save m n: 在m 秒内，如果有n 个键发生改变，则自动触发持久化，通过bgsave执行，如果设置多个、只要满足其一就会触发，配置文件有默认配置(可以注释掉)
- flushall: 用于清空redis所有的数据库，flushdb清空当前redis所在库数据(默认是0号数据库)，会清空RDB文件，同时也会生成dump.rdb、内容为空
- 主从同步: 全量同步时会自动触发bgsave命令，生成rdb发送给从节点

优点:

1. 整个Redis数据库将只包含一个文件 dump.rdb，方便持久化。
2. 容灾性好，方便备份。
3. 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何IO 操作，保证了 redis 的高性能
4. 相对于数据集大时，比AF 的启动效率更高

缺点:

1. 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)
2. 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。会占用cpu

AOF：Append Only File 以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录，调操作系统命令进程刷盘

1. 所有的写命令会追加到 AOF 缓冲中。
2. AOF 缓冲区根据**对应的策略**向硬盘进行同步操作.
3. 随着AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。
4. 当 Redis 重启时，可以加载 AOF 文件进行数据恢复

同步策略：（刷盘命令fsync）

- 每秒同步:异步完成，效率非常高，一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。
- 每修改同步:同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢一条
- 不同步:由操作系统控制，可能丢失较多数据

优点:

1. 数据安全
2. 通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof 工具
   解决数据一致性问题。
3. AOF机制的 rewrite 模式。定期对AOF文件进行重写，以达到压缩的目的

缺点：

- AOF 文件比 RDB 文件大，且恢复速度慢。
- 数据集大的时候，比 rdb 启动效率低l,
- 运行效率没有RDB高

两者使用对比：

- AOF文件比RDB更新频率高，优先使用AOF还原数据
- AOF比RDB更安全也更大
- RDB性能比AOF好
- 如果两个都配了优先加载AOF

缓存雪崩、缓存穿透、缓存击穿

缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉
解决方案:
。缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生
。给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。
。缓存预热
互斥锁.
缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
解决方案:
。接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截
从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒(设置太长会导致正常情况也没法使用)。这样可以防止攻击用户反复用同一个id暴力攻击采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个bitmap 拦载掉，从而游免了对底层存储系统的查询压力